module pat-csp

imports

  pat-csp/Common

context-free start-symbols

  Start

context-free syntax

  Start.PAT_SpecBody = [[{SpecBody "\n"}*]]

  SpecBody = Definition
  SpecBody = LetDefinition
  SpecBody = Channel
  SpecBody = Assert

  Definition.PAT_Definition = [[ID]([{Parameter ", "}*]) = [InterleaveExpr];]

  Parameter.PAT_Parameter = ID

  InterleaveExpr.PAT_InterleaveExpr = [[{ChannelExpr " ||| "}+]]
  InterleaveExpr = InternalChoiceExpr

  InternalChoiceExpr.PAT_InternalChoiceExpr = [[{ChannelExpr " <> "}+]]
  InternalChoiceExpr = ChannelExpr {prefer}

  ChannelExpr.PAT_ChannelExprWrite = [[ID] ! [Expression] -> [ChannelExpr]]
  ChannelExpr.PAT_ChannelExprRead = [[ID] ? [Expression] -> [ChannelExpr]]
  ChannelExpr = EventExpr

  EventExpr = CaseExpr

  CaseExpr = IfExpr

  IfExpr = AtomicExpr

  AtomicExpr.PAT_Process = [[ID]([{Expression ", "}*])]
  AtomicExpr.PAT_Skip = "Skip"
  AtomicExpr.PAT_Stop = "Stop"
  AtomicExpr.PAT_Parens = [([InterleaveExpr])]

  Expression.PAT_Identifier = ID
  Expression.PAT_Integer = INT
  Expression.PAT_True = "true"
  Expression.PAT_False = "false"
  Expression.PAT_Subtract = [[Expression] - [Expression]] {left}
  Expression.PAT_Plus = [[Expression] + [Expression]] {left}
  Expression.PAT_Multiply = [[Expression] * [Expression]] {left}
  Expression = [([Expression])] {bracket}

  LetDefinition.PAT_VarDef = [var [ID];]

  Channel.PAT_Channel = [channel [ID] 0;]

  Assert.PAT_Assert = [#assert [DefinitionRef] [Assertion];]

  Assertion.PAT_AssertDeadlockFree = "deadlockfree"

  DefinitionRef.PAT_DefinitionRef = [[ID]([{ArgumentExpression ","}*])]

  // argumentExpression
  //  : conditionalOrExpression
  //  | recordExpression
  //  ;
  ArgumentExpression.PAT_ArgumentExpression = Expression

context-free priorities
  {left: Expression.PAT_Multiply }
  > {left: Expression.PAT_Subtract Expression.PAT_Plus }
