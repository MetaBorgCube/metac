module generate-sm

language Metac

test generate minimal state machine C code [[
  statemachine X {
    init: start;
    state start {}
  }
]] build generate-c to "
  typedef struct  {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init (X *sm) {
    X_transition_to_state(sm, 0);
  }
  void X_exec (X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          {
            break ;
          }
      }
    }
  }
  "

test generate minimal two states [[
  statemachine X {
    init: middle;
    state start {}
    state middle {}
    state end {}
  }
]] build generate-c to "
  typedef struct {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init(X *sm) {
    X_transition_to_state(sm, 1);
  }
  void X_exec(X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          { break ; }
        case 1:
          { break ; }
        case 2:
          { break ; }
      }
    }
  }"

test sm with epsilon transition [[
  statemachine X {
    init: middle;
    state start {}
    state middle {
      on [1 < 2] -> start;
      on -> end;
    }
    state end {}
  }
]] build generate-c to "
  typedef struct {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init(X *sm) {
    X_transition_to_state(sm, 1);
  }
  void X_exec (X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          { break ;
          }
        case 1:
          {
            if (1 < 2) {
              cont = 1;
              event = -1;
              X_transition_to_state(sm, 0);
              break ;
            }
            if (true) {
              cont = 1;
              event = -1;
              X_transition_to_state(sm, 2);
              break ;
            }
            break ;
          }
        case 2:
          { break ; }
      }
    }
  }"

test sm with transition with params [[
  statemachine X {
    init: start;
    event: foo(int32 a, int32 b);
    state start {
      on foo [1 > 2] / 1; -> end;
    }
    state end {}
  }
]] build generate-c to "
  typedef struct {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init(X *sm) {
    X_transition_to_state(sm, 0);
  }
  void X_exec (X *sm, int event, signed int a, signed int b) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          {
            if (event == 0 && 1 > 2) {
              1;
              cont = 1;
              event = -1;
              X_transition_to_state(sm, 1);
              break ;
            }
            break ;
          }
        case 1:
          { break ; }
      }
    }
  }"

test sm with local variables [[
  statemachine X {
    init: start;
    int32 x;
    state start {}
  }
]] build generate-c to "
  typedef struct {
    int state;
    signed int x;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init (X *sm) {
    X_transition_to_state(sm, 0);
  }
  void X_exec (X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          { break ; }
      }
    }
  }"

test sm state with an entry [[
  statemachine X {
    init: start;
    state start {
      entry {
        1;
      }
    }
  }
]] build generate-c to "
  typedef struct {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    switch (goal) {
      case 0: {
        1;
        break;
      }
    }
    sm->state = goal;
  }
  void X_init(X *sm) {
    X_transition_to_state(sm, 0);
  }
  void X_exec (X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          { break ; }
      }
    }
  }"

test init statemachine code [[
  statemachine X {
    init: start;
    state start {}
  }
  void main () {
    statemachine X y;
  }
]] build generate-c to "
  typedef struct  {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init (X *sm) {
    X_transition_to_state(sm, 0);
  }
  void X_exec (X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          {
            break ;
          }
      }
    }
  }
  void main () {
    X y;
    X_init(&y);
  }
  "

test statemachine trigger event without params [[
  statemachine X {
    init: start;
    event: foo();
    state start {
      on foo -> start;
    }
  }
  void main () {
    statemachine X y;
    y<|foo();
  }
]] build generate-c to "
  typedef struct  {
    int state;
  } X;
  void X_transition_to_state (X *sm, int goal) {
    sm->state = goal;
  }
  void X_init (X *sm) {
    X_transition_to_state(sm, 0);
  }
  void X_exec (X *sm, int event) {
    int cont = 1;
    while (cont) {
      cont = 0;
      switch (sm->state) {
        case 0:
          {
            if (event == 0 && true) {
              cont = 1;
              event = -1;
              X_transition_to_state(sm, 0);
              break ;
            }
            break ;
          }
      }
    }
  }
  void main () {
    X y;
    X_init(&y);
    X_exec(&y, 0);
  }
  "
