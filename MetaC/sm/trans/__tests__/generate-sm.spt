module generate-sm

language Metac

test generate minimal state machine C code [[
  statemachine X {
    init: start;
    state start {}
  }
]] build generate-c to "
  typedef struct {
    int state;
    int pstate;
  } X;
  void X_init(X *sm) {
    sm->state = 0;
    sm->pstate = -1;
  }
  void X_exec (X *sm, int event) {
    int epsilon = 1;
    while (epsilon) {
      epsilon = 0;
      switch (st->state) {
        case 0:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ;
          }
      }
    }
  }"

test generate minimal two states [[
  statemachine X {
    init: middle;
    state start {}
    state middle {}
    state end {}
  }
]] build generate-c to "
  typedef struct {
    int state;
    int pstate;
  } X;
  void X_init(X *sm) {
    sm->state = 1;
    sm->pstate = -1;
  }
  void X_exec(X *sm, int event) {
    int epsilon = 1;
    while (epsilon) {
      epsilon = 0;
      switch (st->state) {
        case 0:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ; }
        case 1:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ; }
        case 2:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ; }
      }
    }
  }"

test sm with epsilon transition [[
  statemachine X {
    init: middle;
    state start {}
    state middle {
      on [1 < 2] -> start;
      on -> end;
    }
    state end {}
  }
]] build generate-c to "
  typedef struct {
    int state;
    int pstate;
  } X;
  void X_init(X *sm) {
    sm->state = 1;
    sm->pstate = -1;
  }
  void X_exec (X *sm, int event) {
    int epsilon = 1;
    while (epsilon) {
      epsilon = 0;
      switch (st->state) {
        case 0:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ;
          }
        case 1:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            if (1 < 2) {
              epsilon = 1;
              sm->state = 0;
              break ;
            }
            if (true) {
              epsilon = 1;
              sm->state = 2;
              break ;
            }
            break ;
          }
        case 2:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ;
          }
      }
    }
  }"

test sm with transition with params [[
  statemachine X {
    init: start;
    event: foo(int32 a, int32 b);
    state start {
      on foo [1 > 2] / 1; -> end;
    }
    state end {}
  }
]] build generate-c to "
  typedef struct {
    int state;
    int pstate;
  } X;
  void X_init(X *sm) {
    sm->state = 0;
    sm->pstate = -1;
  }
  void X_exec (X *sm, int event, signed int a, signed int b) {
    int epsilon = 1;
    while (epsilon) {
      epsilon = 0;
      switch (st->state) {
        case 0:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            if (event == 0 && 1 > 2) {
              1;
              sm->state = 1;
              break ;
            }
            break ;
          }
        case 1:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ;
          }
      }
    }
  }"


test sm with local variables [[
  statemachine X {
    init: start;
    int32 x;
    state start {}
  }
]] build generate-c to "
  typedef struct {
    int state;
    int pstate;
    signed int x;
  } X;
  void X_init(X *sm) {
    sm->state = 0;
    sm->pstate = -1;
  }
  void X_exec (X *sm, int event) {
    int epsilon = 1;
    while (epsilon) {
      epsilon = 0;
      switch (st->state) {
        case 0:
          {
            if (sm->state != sm->pstate) {
              sm->pstate = sm->state;
            }
            break ;
          }
      }
    }
  }"


test sm state with an entry [[
  statemachine X {
    init: start;
    state start {
      entry {
        1;
      }
    }
  }
]] build generate-c to "
  typedef struct {
    int state;
    int pstate;
  } X;
  void X_init(X *sm) {
    sm->state = 0;
    sm->pstate = -1;
  }
  void X_exec (X *sm, int event) {
    int epsilon = 1;
    while (epsilon) {
      epsilon = 0;
      switch (st->state) {
        case 0:
          {
            if (sm->state != sm->pstate) {
              1;
              sm->pstate = sm->state;
            }
            break ;
          }
      }
    }
  }"

