module MetaC-StateMachine-generate

imports

  include/Metac
  libstratego-lib

rules

  generate:
    StateMachine(Identifier(name), Identifier(init), decls, events, states) ->
    [
      <gen-sm-struct> (name, decls),
      <gen-sm-transition-func> (name, states),
      <gen-sm-init> (name, init, states),
      <gen-sm-exec> (name, states, events)
    ]

  // struct

  gen-sm-struct: (name, decls) ->
    Declaration(
      [Typedef(), Struct(None(), struct-declarations)],
      [Declarator(None(), Decl(Identifier(name)))]
    )
    where
      struct-declarations := <conc> (
        [StructDeclaration([Int()], [Declarator(None(), Decl(Identifier("state")))])],
        <map(gen-sm-variable)> decls
      )

  gen-sm-variable:
    Declaration(type, declarator) -> StructDeclaration(type, declarator)

  // init

  gen-sm-init: (name, init, states) ->
    FunDef(
      [Void()],
      FunDeclarator(
        None(),
        Identifier(<conc-strings> (name, "_init")),
        ParameterList([
          Parameter(
            [TypedefName(Identifier(name))],
            Declarator(Some(Pointer([], None())), Decl(Identifier("sm")))
          )
        ])
      ),
      [],
      CompoundStatement([
        ExpressionStatement(Some(Call(
          Var(Identifier(<conc-strings> (name, "_transition_to_state"))),
          [
            Var(Identifier("sm")),
            Integer(initial)
          ]
        )))
      ])
    )
    where
      initial := <find-state-index> (init, states)

  gen-sm-assign-pointer-field: (var, prop, val) ->
    ExpressionStatement(Some(Assign(
     <gen-sm-pointer-field> (var, prop),
     Assign(),
     val
   )))

  gen-sm-pointer-field: (var, field) -> PointerField(Var(Identifier(var)), Identifier(field))

  get-state-name: State(Identifier(name), _, _) -> name

  find-state-index: (name, states) -> index
    where
      index := <add-indices
        ; fetch-elem(\(i, state) -> <eq ; !<dec> i> (name, <get-state-name> state) \)
        ; int-to-string> states

  // exec function

  gen-sm-exec: (name, states, events) ->
    FunDef(
      [Void()],
      FunDeclarator(
        None(),
        Identifier(<conc-strings> (name, "_exec")),
        ParameterList(
          <conc> (
            [
              // state machine instance
              Parameter(
                [TypedefName(Identifier(name))],
                Declarator(Some(Pointer([], None())), Decl(Identifier("sm")))
              ),
              // which event fired
              Parameter(
                [Int()],
                Declarator(None(), Decl(Identifier("event")))
              )
            ],
            // additional event arguments
            event-params
          )
        )
      ),
      [],
      CompoundStatement([
        Declaration(
          [Int()],
          [InitDeclarator(Declarator(None(), Decl(Identifier("cont"))), Integer("1"))]
        ), // int cont = 1;
        While(Var(Identifier("cont")), CompoundStatement([ // while (cont) {}
          // cont = 0;
          <gen-sm-assign-var> ("cont", Integer("0")),
          Switch(
            // switch (sm->state) {}
            PointerField(Var(Identifier("sm")), Identifier("state")),
            CompoundStatement(cases)
          )
        ]))
      ])
    )
    where
      numbered-events := <add-indices
        ; map(\ (i, event) -> (<dec> i, <?Event(Identifier(<id>), _)> event)\)
        > events
      ; event-params := <map(?Event(_, ParameterList(<id>))) ; concat> events
      ; let apply(|i) = <gen-sm-state(|name, states, numbered-events)> (i, <id>)
          in cases := <nmap(apply | 0)> states
        end

  gen-sm-assign-var: (var, val) ->
    ExpressionStatement(
      Some(Assign(Var(Identifier(var)), Assign(), val))
    )

  gen-sm-state(|name, states, events): (i, State(_, entry, trans)) ->
    Case(Integer(<int-to-string> i), CompoundStatement(
      <conc> (transitions, [Break()])
    ))
    where
      transitions := <map(gen-sm-transition(|name, states, events))> trans

  // epsilon transition
  gen-sm-transition(|name, states, events):
    Transition(None(), guard, effect, Identifier(new-state))
    -> <gen-sm-transition-internal> (name, predicate, effect, new-state-index)
    where
      predicate := <gen-sm-guard> guard
      ; new-state-index := <find-state-index> (new-state, states)

  // event action
  gen-sm-transition(|name, states, events):
    Transition(Some(Identifier(event-name)), guard, effect, Identifier(new-state))
    -> <gen-sm-transition-internal> (name, predicate, effect, new-state-index)
    where
      event-index := <find-event-index> (event-name, events)
      ; predicate := LogicalAnd(
          Equal(Var(Identifier("event")), Integer(<int-to-string> event-index)),
          <gen-sm-guard> guard
        )
      ; new-state-index := <find-state-index> (new-state, states)

  gen-sm-transition-internal: (name, predicate, effect, new-state-index)
    -> If(predicate, body)
    where
      body := CompoundStatement(
          <conc> (
            <gen-sm-effect> effect,
            [
              <gen-sm-assign-var> ("cont", Integer("1")),
              <gen-sm-assign-var> ("event", Integer("-1")),
              ExpressionStatement(Some(Call(
                Var(Identifier(<conc-strings> (name, "_transition_to_state"))),
                [Var(Identifier("sm")), Integer(new-state-index)]
              ))),
              Break()
            ]
          )
        )

  find-event-index: (name, events) -> index
    where
      index := <fetch-elem(\ (i, event-name) -> <eq ; !i> (event-name, name) \)> events

  gen-sm-guard: None() -> True()
  gen-sm-guard: Guard(e) -> e

  gen-sm-effect: None() -> []
  gen-sm-effect: Effect(stmt) -> [stmt]

  // x_transition_to_state
  gen-sm-transition-func: (name, states) -> FunDef(
      [Void()],
      FunDeclarator(
        None(),
        Identifier(<conc-strings> (name, "_transition_to_state")),
        ParameterList([
          Parameter(
            [TypedefName(Identifier(name))],
            Declarator(Some(Pointer([], None())), Decl(Identifier("sm")))
          ),
          Parameter([Int()], Declarator(None(), Decl(Identifier("goal"))))
        ])
      ),
      [],
      CompoundStatement(<concat> [
        <gen-sm-entries-switch> entries,
        [<gen-sm-assign-pointer-field> ("sm", "state", Var(Identifier("goal")))]
      ])
    )
    where
      entries := <add-indices
        ; filter(\ (i, state) -> (<dec> i, <?State(_, <id>, _) ; ?Entry(_)> state) \)
        > states

  gen-sm-entries-switch: [] -> []
  gen-sm-entries-switch: entries -> [
      Switch(
        Var(Identifier("goal")),
        CompoundStatement(<map(gen-sm-entry-case)> entries)
      )
    ]

  gen-sm-entry-case: (state-index, Entry(CompoundStatement(stmts))) ->
    Case(
      Integer(<int-to-string> state-index),
      CompoundStatement(<conc> (stmts, [Break()]))
    )
