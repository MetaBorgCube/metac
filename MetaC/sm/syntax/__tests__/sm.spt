module sm

language Metac

start symbol Program

test parse empty sm [[
  statemachine Name {
    init: start;
    state start {
    }
  }
]] parse to Program(_, [
    StateMachine(
      Identifier("Name"),
      Identifier("start"),
      [], [],
      [State(Identifier("start"), None(), [])]
    )
  ])

test statemachine with a local variable decl [[
  statemachine Name {
    init: start;
    int32 x;
    state start {
    }
  }
]] parse to Program(_, [StateMachine(_, _,
    [Declaration([Int32], [Declarator(None, Decl(Identifier("x")))])],
    [],
    [_]
  )])

test statemachine with an epsilon transition [[
  statemachine Name {
    init: start;
    state start {
      on -> finish;
    }
    state finish {}
  }
]] parse to Program(_, [StateMachine(_, _, [], [],
    [
      State(Identifier("start"), None(), [
        Transition(None(), None(), None(), Identifier("finish"))
      ]),
      State(Identifier("finish"), None(), [])
    ]
  )])


test statemachine with an epsilon transition with guard [[
  statemachine Name {
    init: start;
    state start {
      on [1 < 3] -> finish;
    }
    state finish {}
  }
]] parse to Program(_, [StateMachine(_, _, [], [],
    [
      State(Identifier("start"), None(), [
        Transition(None(), Guard(Lt(_, _)), None(), Identifier("finish"))
      ]),
      State(Identifier("finish"), None(),[])
    ]
  )])

test statemachine with an epsilon transition with effect [[
  statemachine Name {
    init: start;
    state start {
      on / printf("x"); -> finish;
    }
    state finish {}
  }
]] parse to Program(_, [StateMachine(_, _, [], [],
    [
      State(Identifier("start"), None(), [
        Transition(None(), None, Effect(ExpressionStatement(_)), Identifier("finish"))
      ]),
      State(Identifier("finish"), None(), [])
    ]
  )])

test statemachine with transition [[
  statemachine Name {
    init: start;
    event: foo(int32 a, int32 b);
    event: bar();
    state start {
      on foo -> finish;
      on bar -> finish;
    }
    state finish {}
  }
]] parse to Program(_, [StateMachine(_, _, [],
    [
      Event(
        Identifier("foo"),
        ParameterList([
          Parameter([Int32], Declarator(None, Decl(Identifier("a")))),
          Parameter([Int32], Declarator(None, Decl(Identifier("b"))))
        ])
      ),
      Event(Identifier("bar"), ParameterList([]))
    ],
    [
      State(Identifier("start"), None(), [
        Transition(Some(Identifier("foo")), None, None, Identifier("finish")),
        Transition(Some(Identifier("bar")), None, None, Identifier("finish"))
      ]),
      State(Identifier("finish"), None(), [])
    ]
  )])

test state with entry action [[
  statemachine X {
    init: start;
    state start {
      entry {
        1;
      }
    }
  }
]] parse to Program(_, [StateMachine(_, _, [], [], [
    State(
      Identifier("start"),
      Entry(CompoundStatement([
        ExpressionStatement(Some(Integer("1")))
      ])),
      []
    )
  ])])
