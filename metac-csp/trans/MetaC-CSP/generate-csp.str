module MetaC-CSP/generate-csp

imports

  signatures/BaseC/Program-sig
  signatures/MetaC-CSP-sig
  BaseC/desugar/constructors
  MetaC-CSP/desugar
  metac-runtime-utils/string
  runtime/analysis/resolve
  runtime/types/query
  editor-common.generated

rules

  generate-csp-resolve = analysis-resolve(|<language>, <project-path>)

  generate-csp-register-type(|x) = fail
  generate-csp-register = generate-csp-register-type(|"CSP")

  generate-csp: ("CSP", ast@Program(_, decls)) ->
    <collect-all(generate-csp(|ast)) ; map(!Some(<id>))> decls

  generate-csp(|ast): CSPPar(ps) ->
    $[
    [channels]
    [processes]
    [par-name]() = [par];
    #assert [par-name] deadlockfree;
    ]
    where
      all-arguments := <mapconcat(?CSPInvokeProcess(_, <id>))> ps
      ; chan-table := <foldr(!<new-hashtable>, generate-csp-chan-table-put)> all-arguments
      ; channels := <
          hashtable-values
          ; map(\chan -> $[channel [chan] 0;] \)
          ; join-strings(|"\n")
        > chan-table
      ; invocations := <map(generate-csp-process(|ast, chan-table))> ps
      ; par := <map(?(<id>, _)) ; join-strings(|" ||| ")> invocations
      ; par-name := <newname> "PAR_"
      ; processes := <map(?(_, <id>)) ; join-strings(|"\n")> invocations

  // creator of the chan-names table
  generate-csp-chan-table-put:
    (arg, table) -> <hashtable-put(|def', <newname> "chan")> table
    where
      <get-type ; ?CSPChan(_)> arg
      ; def' := <?Var(Identifier(<id>)) ; generate-csp-resolve> arg
  generate-csp-chan-table-put: (arg, table) -> table

  generate-csp-process(|ast, chan-table):
    CSPInvokeProcess(Identifier(name), arguments) -> (name', process-string)
    where
      name' := <newname> name
      // hack to get the original AST declaration of this process
      ; definition := <generate-csp-resolve> name
      ; process := <collect-one(?CSPProcess(Identifier(_{definition}), _, _))> ast
      // create local instances of channels
      ; chan-args := <map-with-index(generate-csp-argument(|chan-table))> arguments
      ; process-string := <generate-csp-process-string(|name', chan-args)> process

  // lookup the names in the chan-table
  generate-csp-argument(|chan-table):
    (i, Var(Identifier(name))) -> (i, Some(chan-name))
    where chan-name := <hashtable-get(|<generate-csp-resolve> name)> chan-table
  generate-csp-argument(|chan-table): (i, _) -> (i, None())

  // generate the process CSP definition
  generate-csp-process-string(|name, chan-args):
    CSPProcess(_, CSPProcessParameterList(params), body)
    -> $[[name]() = [comms] -> Skip;]
    where
      param-defs := <map-with-index(generate-csp-param-lookup(|chan-args))> params
      ; communications := <collect-all(?CSPChanWrite(_, _, _) <+ ?CSPAnonChanRead(_, _) <+ ?CSPChanRead(_, _))> body
      ; comms := <map(generate-csp-comm-string(|param-defs)) ; join-strings(|" -> ")> communications

  // associate the process param defs with the linked global channel names
  generate-csp-param-lookup(|chans):
    (i, FunDefinitionParameter(Type(_, CSPChan(_)), Decl(Identifier(name{def'@Def(_)}))))
    -> Some((def', chan))
    where (_, chan) := <fetch-elem(?(i, _))> chans
  generate-csp-param-lookup(|chans): _ -> None()

  generate-csp-comm-chan-name(|param-defs): c -> chan
    where
      def' := <generate-csp-resolve> c
      ; Some((_, Some(chan))) := <fetch-elem(?Some((def', _)))> param-defs

  generate-csp-comm-string(|p-defs):
    CSPChanWrite(_, Var(Identifier(c)), _)
    -> $[[<generate-csp-comm-chan-name(|p-defs)> c] ! 1]

  generate-csp-comm-string(|p-defs):
    CSPChanRead(Var(Identifier(c)), _)
    -> $[[<generate-csp-comm-chan-name(|p-defs)> c] ? 1]

  generate-csp-comm-string(|p-defs):
    CSPAnonChanRead(Var(Identifier(c)), _)
    -> $[[<generate-csp-comm-chan-name(|p-defs)> c] ? 1]
