module MetaC-CSP/generate-csp

imports

  signatures/BaseC/Program-sig
  signatures/MetaC-CSP-sig
  BaseC/desugar/constructors
  MetaC-CSP/desugar
  MetaC-CSP/generate-csp/expr
  MetaC-CSP/utils
  metac-runtime-utils/string
  runtime/types/query
  signatures/pat-csp-sig

rules

  generate-csp-register-type(|x) = fail
  generate-csp-register = generate-csp-register-type(|"CSP")

  generate-csp: ("CSP", ast@Program(_, decls)) ->
    <collect-all(can-generate-csp) ; map(generate-csp(|ast))> decls

  can-generate-csp = ?CSPPar(_)
  generate-csp(|ast): CSPPar(ps) -> <concat> [
      channels,
      processes,
      [
        Definition(par-name, [], InterleaveExpr(par)),
        Assert(DefinitionRef(par-name, []), AssertDeadlockFree())
      ]
    ]
    where
      all-arguments := <mapconcat(?CSPInvokeProcess(_, <id>, _))> ps
      ; chan-table := <foldr(!<new-hashtable>, generate-csp-chan-table-put)> all-arguments
      ; channels := <hashtable-values; map(\chan -> Channel(chan) \)> chan-table
      ; invocations := <map(generate-csp-process(|ast, chan-table))> ps
      ; par := <map(Fst)> invocations
      ; par-name := <newname> "PAR_"
      ; processes := <map(Snd)> invocations

  // creator of the chan-names table
  generate-csp-chan-table-put:
    (arg, table) -> <hashtable-put(|def', <newname> "chan")> table
    where
      <get-type ; ?CSPChan(_)> arg
      ; def' := <?Var(Identifier(<id>)) ; generate-csp-resolve> arg
  generate-csp-chan-table-put: (arg, table) -> table

  generate-csp-process(|ast, chan-table):
    CSPInvokeProcess(Identifier(name), arguments, init-state)
    -> (Process(csp-name, csp-init-state), csp-process)
    where
      csp-name := <newname> name
      ; csp-init-state := <(?Some(CSPInvokeState(<id>)) <+ ![]) ; map(generate-csp-expr)> init-state
      // hack to get the original AST declaration of this process
      ; definition := <generate-csp-resolve> name
      ; process := <collect-one(?CSPProcess(Identifier(_{definition}), _, _, _))> ast
      // create local instances of channels
      ; chan-args := <map-with-index(generate-csp-argument(|chan-table))> arguments
      ; csp-process := <generate-csp-process-ast(|csp-name, chan-args)> process

  // lookup the names in the chan-table
  generate-csp-argument(|chan-table):
    (i, Var(Identifier(name))) -> (i, Some(chan-name))
    where chan-name := <hashtable-get(|<generate-csp-resolve> name)> chan-table
  generate-csp-argument(|chan-table): (i, _) -> (i, None())

  // generate the process CSP definition
  generate-csp-process-ast(|name, chan-args):
    CSPProcess(_, CSPProcessParameterList(params), state, body)
    -> Definition(name, state-vars, process)
    where
      state-vars := <
          (?CSPStateParameterList(<id>) <+ ![])
          ; map(\ FunDefinitionParameter(_, Decl(Identifier(name))) -> Parameter(<strip-annos> name) \)
        > state
      ; param-defs := <map-with-index(generate-csp-param-lookup(|chan-args))> params
      ; process := <generate-csp-def-expr(|name, param-defs)> (body, Skip())

  // associate the process param defs with the linked global channel names
  generate-csp-param-lookup(|chans):
    (i, FunDefinitionParameter(Type(_, CSPChan(_)), Decl(Identifier(name{def'@Def(_)}))))
    -> Some((def', chan))
    where (_, chan) := <fetch-elem(?(i, _))> chans
  generate-csp-param-lookup(|chans): _ -> None()

  generate-csp-comm-chan-name(|param-defs): c -> chan
    where
      def' := <generate-csp-resolve> c
      ; Some((_, Some(chan))) := <fetch-elem(?Some((def', _)))> param-defs

  generate-csp-def-expr(|name, p-defs):
    (CompoundStatement(stmt), p)
    -> <foldr(!Skip(), generate-csp-def-expr(|name, p-defs))> stmt

  generate-csp-def-expr(|name, p-defs):
    (ExpressionStatement(Some(e)), p) -> <generate-csp-def-expr(|name, p-defs)> (e, p)

  generate-csp-def-expr(|name, p-defs):
    (CSPChanWrite(_, Var(Identifier(c)), _), p)
    -> ChannelExprWrite(<generate-csp-comm-chan-name(|p-defs)> c, Integer("1"), p)

  generate-csp-def-expr(|name, p-defs):
    (CSPChanRead(Var(Identifier(c)), _), p)
    -> ChannelExprRead(<generate-csp-comm-chan-name(|p-defs)> c, Integer("1"), p)

  generate-csp-def-expr(|name, p-defs):
    (CSPAnonChanRead(Var(Identifier(c)), _), p)
    -> ChannelExprRead(<generate-csp-comm-chan-name(|p-defs)> c, Integer("1"), p)

  generate-csp-def-expr(|name, p-defs):
    (Call(v@Var(_), args), p)
    -> Process(name, <map(generate-csp-expr)> args)

  generate-csp-def-expr(|name, p-defs):
    (If(_, stmt), p)
    -> Parens(InternalChoiceExpr([
        <generate-csp-def-expr(|name, p-defs)> (stmt, Skip()),
        p
      ]))

  generate-csp-def-expr(|name, p-defs):
    (IfElse(_, t-branch, f-branch), p)
    -> Parens(InternalChoiceExpr([
        <generate-csp-def-expr(|name, p-defs)> (t-branch, Skip()),
        <generate-csp-def-expr(|name, p-defs)> (f-branch, Skip())
      ]))

  generate-csp-def-expr(|name, d): (stmt, p) -> p
