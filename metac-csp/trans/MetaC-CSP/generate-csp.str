module MetaC-CSP/generate-csp

imports

  runtime/types/query
  signatures/BaseC/Program-sig
  signatures/MetaC-CSP-sig
  signatures/pat-csp-sig
  names/MetaC-CSP/names
  names/BaseC/names/variables
  BaseC/desugar/constructors
  MetaC-CSP/desugar
  MetaC-CSP/utils
  MetaC-CSP/generate-csp/expr
  MetaC-CSP/generate-csp/alts
  metac-runtime-utils/string

rules

  generate-csp-register-type(|x) = fail
  generate-csp-register = generate-csp-register-type(|"CSP")

  generate-csp: ("CSP", ast@Program(_, decls)) -> [
      defines,
      processes
    ]
    where
      defines := <generate-csp-defines> ast
      ; processes := <collect-all(can-generate-csp) ; map(generate-csp(|ast))> decls

  can-generate-csp = ?CSPPar(_)
  generate-csp(|ast): CSPPar(ps) -> <concat> [
      channels,
      processes,
      [
        PAT_Definition(par-name, [], PAT_InterleaveExpr(par)),
        PAT_Assert(PAT_DefinitionRef(par-name, []), PAT_AssertDeadlockFree())
      ]
    ]
    where
      all-arguments := <mapconcat(?CSPInvokeProcess(_, <id>, _))> ps
      ; chan-table := <foldr(!<new-hashtable>, generate-csp-chan-table-put)> all-arguments
      ; channels := <hashtable-values; map(\chan -> PAT_Channel(chan) \)> chan-table
      ; invocations := <map(generate-csp-process(|ast, chan-table))> ps
      ; par := <map(Fst)> invocations
      ; par-name := <newname> "PAR_"
      ; processes := <map(Snd)> invocations

  generate-csp-defines =
    ?Program(_, <id>)
    ; filter(?Define(_, Integer(_)))
    ; map(\ Define(Identifier(name), Integer(value)) -> <strip-annos> PAT_Define(name, value) \)

  // creator of the chan-names table
  generate-csp-chan-table-put:
    (arg@Var(Identifier(name)), table) -> <hashtable-put(|def', <newname> $[chan_[name]_])> table
    where
      <get-type ; ?CSPChan(_)> arg
      ; def' := <generate-csp-resolve> name
  generate-csp-chan-table-put: (arg, table) -> table

  generate-csp-process(|ast, chan-table):
    CSPInvokeProcess(Identifier(name), arguments, init-state)
    -> (PAT_Process(csp-name, csp-init-state), csp-process)
    where
      csp-name := <newname> name
      ; csp-init-state := <(?Some(CSPInvokeState(<id>)) <+ ![]) ; map(generate-csp-expr)> init-state
      // hack to get the original AST declaration of this process
      ; definition := <generate-csp-resolve> name
      ; process := <collect-one(?CSPProcess(Identifier(_{definition}), _, _, _))> ast
      // create local instances of channels
      ; chan-args := <map-with-index(generate-csp-argument(|chan-table))> arguments
      ; csp-process := <generate-csp-process-ast(|csp-name, chan-args)> process

  // lookup the names in the chan-table
  generate-csp-argument(|chan-table):
    (i, Var(Identifier(name))) -> (i, Some(chan-name))
    where chan-name := <hashtable-get(|<generate-csp-resolve> name)> chan-table
  generate-csp-argument(|chan-table): (i, _) -> (i, None())

  // generate the process CSP definition
  generate-csp-process-ast(|name, chan-args):
    CSPProcess(_, CSPProcessParameterList(params), state, body)
    -> PAT_Definition(name, state-vars, process)
    where
      states := <(?CSPStateParameterList(<id>) <+ ![])> state
      ; state-defs := <map(?FunDefinitionParameter(_, Decl(Identifier(_{<id>}))))> states
      ; state-vars := <map(\ FunDefinitionParameter(_, Decl(Identifier(name))) -> PAT_Parameter(<strip-annos> name) \)> states
      ; param-defs := <map-with-index(generate-csp-param-lookup(|chan-args))> params
      ; process := <generate-csp-def-expr(|name, param-defs, state-defs)> (body, PAT_Skip())

  // associate the process param defs with the linked global channel names
  generate-csp-param-lookup(|chans):
    (i, FunDefinitionParameter(Type(_, CSPChan(_)), Decl(Identifier(name{def'@Def(_)}))))
    -> Some((def', chan))
    where (_, chan) := <fetch-elem(?(i, _))> chans
  generate-csp-param-lookup(|chans): _ -> None()

  generate-csp-comm-chan-name(|param-defs): c -> chan
    where
      def' := <generate-csp-resolve> c
      ; Some((_, Some(chan))) := <fetch-elem(?Some((def', _)))> param-defs

  generate-csp-def-expr(|name, p-defs, s-defs):
    (CompoundStatement(stmt), p)
    -> <foldr(!PAT_Skip(), generate-csp-def-expr(|name, p-defs, s-defs))> stmt

  generate-csp-def-expr(|name, p-defs, s-defs):
    (ExpressionStatement(Some(e)), p) -> <generate-csp-def-expr(|name, p-defs, s-defs)> (e, p)

  generate-csp-def-expr(|name, p-defs, s-defs):
    (CSPChanWrite(_, Var(Identifier(c)), _), p)
    -> PAT_ChannelExprWrite(<generate-csp-comm-chan-name(|p-defs)> c, PAT_Integer("1"), p)

  generate-csp-def-expr(|name, p-defs, s-defs):
    (CSPChanRead(Var(Identifier(c)), _), p)
    -> PAT_ChannelExprRead(<generate-csp-comm-chan-name(|p-defs)> c, PAT_Integer("1"), p)

  generate-csp-def-expr(|name, p-defs, s-defs):
    (CSPAnonChanRead(Var(Identifier(c)), _), p)
    -> PAT_ChannelExprRead(<generate-csp-comm-chan-name(|p-defs)> c, PAT_Integer("1"), p)

  // The recursive process call, need to refer to the process
  generate-csp-def-expr(|name, p-defs, s-defs):
    (Call(v@Var(_), args), p)
    -> PAT_Process(name, <map(generate-csp-expr(|s-defs))> args)
    where <get-process-state> v

  // If expr depending only on constants and state vars
  generate-csp-def-expr(|name, p-defs, s-defs):
    (If(predicate, stmt), p)
    -> PAT_Parens(PAT_SequentialExpr([
        PAT_IfExpr(
          <generate-csp-expr(|s-defs)> predicate,
          <generate-csp-def-expr(|name, p-defs, s-defs)> (stmt, PAT_Skip())
        ),
        p
      ]))
      where <generate-csp-test-state-vars(|s-defs)> predicate

  // something we can't model, depends on other stuff, use
  // an InternalChoice only
  generate-csp-def-expr(|name, p-defs, s-defs):
    (If(predicate, stmt), p)
    -> PAT_Parens(PAT_SequentialExpr([
      PAT_Parens(PAT_InternalChoiceExpr([
        <generate-csp-def-expr(|name, p-defs, s-defs)> (stmt, PAT_Skip()),
        PAT_Skip()
      ])),
      p
    ]))

  generate-csp-def-expr(|name, p-defs, s-defs):
    (IfElse(predicate, t-branch, f-branch), p)
    -> PAT_Parens(PAT_SequentialExpr([
        PAT_IfElseExpr(
          <generate-csp-expr(|s-defs)> predicate,
          <generate-csp-def-expr(|name, p-defs, s-defs)> (t-branch, PAT_Skip()),
          <generate-csp-def-expr(|name, p-defs, s-defs)> (f-branch, PAT_Skip())
        ),
        p
      ]))
      where <generate-csp-test-state-vars(|s-defs)> predicate

  generate-csp-def-expr(|name, p-defs, s-defs):
    (IfElse(_, t-branch, f-branch), p)
    -> PAT_Parens(PAT_SequentialExpr([
        PAT_Parens(PAT_InternalChoiceExpr([
          <generate-csp-def-expr(|name, p-defs, s-defs)> (t-branch, PAT_Skip()),
          <generate-csp-def-expr(|name, p-defs, s-defs)> (f-branch, PAT_Skip())
        ])),
        p
      ]))

  generate-csp-test-state-vars(|s-defs) =
    collect-all(?Var(Identifier(<id>)))
    ; all(generate-csp-resolve ; ?d ; <elem> (d, s-defs) <+ (get-define-value ; ?Integer(_)))

  generate-csp-def-expr(|name, d, s-defs): (stmt, p) -> p
