module MetaC-CSP/generate-csp

imports

  signatures/BaseC/Program-sig
  signatures/MetaC-CSP-sig
  BaseC/desugar/constructors
  MetaC-CSP/desugar
  metac-runtime-utils/string
  runtime/analysis/resolve
  runtime/types/query
  editor-common.generated
  signatures/pat-csp-sig

rules

  generate-csp-resolve = analysis-resolve(|<language>, <project-path>)

  generate-csp-register-type(|x) = fail
  generate-csp-register = generate-csp-register-type(|"CSP")

  generate-csp: ("CSP", ast@Program(_, decls)) ->
    <collect-all(can-generate-csp) ; map(generate-csp(|ast))> decls

  can-generate-csp = ?CSPPar(_)
  generate-csp(|ast): CSPPar(ps) -> <concat> [
      channels,
      processes,
      [
        Definition(par-name, [], InterleaveExpr(par)),
        Assert(DefinitionRef(par-name, []), AssertDeadlockFree())
      ]
    ]
    where
      all-arguments := <mapconcat(?CSPInvokeProcess(_, <id>, _))> ps
      ; chan-table := <foldr(!<new-hashtable>, generate-csp-chan-table-put)> all-arguments
      ; channels := <hashtable-values; map(\chan -> Channel(chan) \)> chan-table
      ; invocations := <map(generate-csp-process(|ast, chan-table))> ps
      ; par := <map(?(process, _) ; !Process(process, []))> invocations
      ; par-name := <newname> "PAR_"
      ; processes := <map(?(_, <id>))> invocations

  // creator of the chan-names table
  generate-csp-chan-table-put:
    (arg, table) -> <hashtable-put(|def', <newname> "chan")> table
    where
      <get-type ; ?CSPChan(_)> arg
      ; def' := <?Var(Identifier(<id>)) ; generate-csp-resolve> arg
  generate-csp-chan-table-put: (arg, table) -> table

  generate-csp-process(|ast, chan-table):
    CSPInvokeProcess(Identifier(name), arguments, state) -> (name', process-string)
    where
      name' := <newname> name
      // hack to get the original AST declaration of this process
      ; definition := <generate-csp-resolve> name
      ; process := <collect-one(?CSPProcess(Identifier(_{definition}), _, _, _))> ast
      // create local instances of channels
      ; chan-args := <map-with-index(generate-csp-argument(|chan-table))> arguments
      ; process-string := <generate-csp-process-ast(|name', chan-args)> process

  // lookup the names in the chan-table
  generate-csp-argument(|chan-table):
    (i, Var(Identifier(name))) -> (i, Some(chan-name))
    where chan-name := <hashtable-get(|<generate-csp-resolve> name)> chan-table
  generate-csp-argument(|chan-table): (i, _) -> (i, None())

  // generate the process CSP definition
  generate-csp-process-ast(|name, chan-args):
    CSPProcess(_, CSPProcessParameterList(params), _, body)
    -> Definition(name, [], process)
    where
      param-defs := <map-with-index(generate-csp-param-lookup(|chan-args))> params
      ; communications := <collect-all(?CSPChanWrite(_, _, _) <+ ?CSPAnonChanRead(_, _) <+ ?CSPChanRead(_, _))> body
      ; process := <foldr(!Skip(), generate-csp-comm-ast(|param-defs))> communications

  // associate the process param defs with the linked global channel names
  generate-csp-param-lookup(|chans):
    (i, FunDefinitionParameter(Type(_, CSPChan(_)), Decl(Identifier(name{def'@Def(_)}))))
    -> Some((def', chan))
    where (_, chan) := <fetch-elem(?(i, _))> chans
  generate-csp-param-lookup(|chans): _ -> None()

  generate-csp-comm-chan-name(|param-defs): c -> chan
    where
      def' := <generate-csp-resolve> c
      ; Some((_, Some(chan))) := <fetch-elem(?Some((def', _)))> param-defs

  generate-csp-comm-ast(|p-defs):
    (CSPChanWrite(_, Var(Identifier(c)), _), p)
    -> ChannelExprWrite(<generate-csp-comm-chan-name(|p-defs)> c, Integer("1"), p)

  generate-csp-comm-ast(|p-defs):
    (CSPChanRead(Var(Identifier(c)), _), p)
    -> ChannelExprRead(<generate-csp-comm-chan-name(|p-defs)> c, Integer("1"), p)

  generate-csp-comm-ast(|p-defs):
    (CSPAnonChanRead(Var(Identifier(c)), _), p)
    -> ChannelExprRead(<generate-csp-comm-chan-name(|p-defs)> c, Integer("1"), p)
