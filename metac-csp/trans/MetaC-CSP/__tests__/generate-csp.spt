module generate-csp

language MetaC

test one process [[
  process p(chan<int> a) {}
  void f() {
    chan<int> a;
    par { p(a); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Channel(_),
    PAT_Definition(_, [], PAT_Skip()),
    PAT_Definition(_, [], PAT_InterleaveExpr([PAT_Process(_, [])])),
    PAT_Assert(PAT_DefinitionRef(_, []), PAT_AssertDeadlockFree())
  ])

test process with read and write [[
  process p(chan<int> a) {
    int x;
    a ? x;
    a ! x;
  }
  void f() {
    chan<int> a;
    par { p(a); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Channel(_),
    PAT_Definition(_, [],
      PAT_ChannelExprRead(_, _,
        PAT_ChannelExprWrite(_, _,
          PAT_Skip()))),
    PAT_Definition(_, [], PAT_InterleaveExpr([PAT_Process(_, [])])),
    PAT_Assert(PAT_DefinitionRef(_, []), PAT_AssertDeadlockFree())
  ])

test process with read and write [[
  process p(chan<int> a) {
    int x;
    a ? x;
    a ! x;
    p();
  }
  void f() {
    chan<int> a;
    par { p(a); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Channel(_),
    PAT_Definition(_, [],
      PAT_ChannelExprRead(_, _,
        PAT_ChannelExprWrite(_, _,
          PAT_Process(_, [])))),
    PAT_Definition(_, [], PAT_InterleaveExpr([PAT_Process(_, [])])),
    PAT_Assert(PAT_DefinitionRef(_, []), PAT_AssertDeadlockFree())
  ])

test recursive process with state [[
  void g() {}
  process p(@ int b) {
    g();
    p(1);
  }
  void f() {
    par { p(@0); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Definition(_, [PAT_Parameter("b")],
      PAT_Process(_, [PAT_Integer("1")])),
    PAT_Definition(_, [], PAT_InterleaveExpr([PAT_Process(_, [PAT_Integer("0")])])),
    PAT_Assert(PAT_DefinitionRef(_, []), PAT_AssertDeadlockFree())
  ])

test process an if [[
  process p(chan<int> a @ int b) {
    if (1) a ! 1;
    p(1);
  }
  void f() {
    chan<int> a;
    par { p(a @0); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Channel(_),
    PAT_Definition(_, [PAT_Parameter("b")],
      PAT_Parens(PAT_InternalChoiceExpr([
        PAT_ChannelExprWrite(_, _, PAT_Skip()),
        PAT_Process(_, [PAT_Integer("1")])
      ]))),
    PAT_Definition(_, [], PAT_InterleaveExpr([PAT_Process(_, [PAT_Integer("0")])])),
    PAT_Assert(PAT_DefinitionRef(_, []), PAT_AssertDeadlockFree())
  ])

test process an if-else [[
  process p(chan<int> a @ int b) {
    if (1) a ! 1;
    else {
      p(1);
    }
  }
  void f() {
    chan<int> a;
    par { p(a @0); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Channel(_),
    PAT_Definition(_, [PAT_Parameter("b")],
      PAT_Parens(PAT_InternalChoiceExpr([
        PAT_ChannelExprWrite(_, _, PAT_Skip()),
        PAT_Process(_, [PAT_Integer("1")])
      ]))),
    PAT_Definition(_, [], PAT_InterleaveExpr([PAT_Process(_, [PAT_Integer("0")])])),
    PAT_Assert(PAT_DefinitionRef(_, []), PAT_AssertDeadlockFree())
  ])

test process an if-else [[
  process p(@ int b) {
    p(b + (1 + 1) * b - (2 * 2));
  }
  void f() {
    par { p(@0); }
  }
]] build generate-csp-test to PAT_SpecBody([
    PAT_Definition(_, [PAT_Parameter("b")],
      PAT_Process(_, [
        PAT_Subtract(
          PAT_Plus(
            PAT_Var("b"),
            PAT_Multiply(
              PAT_Plus(PAT_Integer("1"), PAT_Integer("1")),
              PAT_Var("b")
            )
          ),
          PAT_Multiply(
            PAT_Integer("2"),
            PAT_Integer("2")
          )
        )
      ])
    ),
    _,
    _
  ])
