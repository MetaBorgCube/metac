module MetaC-CSP/generate-c

imports

  signatures/BaseC-sig
  signatures/MetaC-CSP-sig
  BaseC/desugar/constructors
  BaseC/generate/declarations
  runtime/types/-
  names/MetaC-CSP/names
  MetaC-CSP/desugar
  MetaC-CSP/names-custom

rules

  // test strategy that changes the <newname> in CSPChanWrite to something deterministic
  generate-c = fail
  generate-c-csp-test: t@(selected, position, ast, path, project-path)
    -> <generate-c> (new-selected, position, ast, path, project-path)
    where
      new-selected := <bottomup(try(
          \ CSPChanWrite(_, a, b) -> CSPChanWrite("temp_var", a, b) \
        ))> selected

  generate-include-headers: CSPChan(_) -> Include("csp.h")
  generate-include-headers: CSPProcess(_, _, _) -> Include("process.h")

  generate02:
    Type(mods1, CSPChan(Type(mods2, _)))
    -> Type(merged-mods, Pointer(TypedefName(Identifier("Channel"))))
    where
      merged-mods := <conc ; uniq> (mods1, mods2)

  // Change chan<T> channel variable declarations
  generate01:
    VarDeclaration(
      storage,
      type@Type(mods1, CSPChan(Type(mods2, _))),
      decl@Decl(Identifier(name)),
      None()
    ) ->
    [
      VarDeclaration(
        storage,
        type,
        decl,
        None()
      ),
      CompoundStatement([
        VarDeclaration(
          [],
          Type([], TypedefName(Identifier("Channel"))),
          Decl(Identifier(temp-var-name)),
          None()
        ),
        ExpressionStatement(Some(
          Assign(
            Var(Identifier(name)),
            Assign(),
            Address(Var(Identifier(temp-var-name)))
          )
        )),
        ExpressionStatement(Some(
          Call(
            Var(Identifier("CSP_chanInit")),
            [
              Var(Identifier(name)),
              Var(Identifier("CSP_ONE2ONE_CHANNEL")),
              Integer("0")
            ]
          )
        ))
      ])
    ]
    with
      temp-var-name := <conc-strings> ("_", name)

  // Change process definitions, into a structure that are used for storing arguments.
  // and a function with the Process object as argument.
  generate01:
    CSPProcess(Identifier(name), CSPProcessParameterList(params), body)
    -> [
      TypedefDeclaration(
        Type([], Struct(
          None(),
          process-parameters
        )),
        Decl(Identifier(struct-name))
      ),
      FunDefinition(
        Identifier(name),
        [],
        Type([], Function(
          Type([], Void()),
          [Type([], Pointer(TypedefName(Identifier("Process"))))]
        )),
        [FunDefinitionParameter(
          Type([], Pointer(TypedefName(Identifier("Process")))),
          Decl(Identifier("p"))
        )],
        CompoundStatement(function-body)
      )
    ]
  where
    s-name := <strip-annos> name
    ; struct-name := <conc-strings> (s-name, "_ProcessArgs")
    ; process-parameters := <map(generate-process-param-struct-field)> params
    ; process-parameters-variables := <map(generate-process-param-variable)> params
    ; function-body := <concat> [
        [VarDeclaration(
          [],
          Type([], Pointer(TypedefName(Identifier(struct-name)))),
          Decl(Identifier("args")),
          Some(PointerField(Var(Identifier("p")), Identifier("args")))
        )],
        process-parameters-variables,
        [body]
      ]

  generate-process-param-struct-field:
    FunDefinitionParameter(type, decl)
    -> StructDeclarator(type, decl, None())

  generate-process-param-variable:
    FunDefinitionParameter(type, decl@Decl(name))
    -> VarDeclaration([], type, decl, Some(
      PointerField(Var(Identifier("args")), name)
    ))

  // test which chanOutInt* function name we should use
  generate-csp-numeric-out-fn-name = (?Int64() <+ ?UInt64()) ; !"CSP_chanOutInt64"
  generate-csp-numeric-out-fn-name = (?Int32() <+ ?UInt32()) ; !"CSP_chanOutInt32"
  generate-csp-numeric-out-fn-name = (?Int16() <+ ?UInt16()) ; !"CSP_chanOutInt16"
  generate-csp-numeric-out-fn-name = (?Int8() <+ ?UInt8())   ; !"CSP_chanOutInt8"

  // add a temp variable in this scope that can be used by the CSPChanWrite
  // transformed code
  generate-temp-scope-variable:
    CSPChanWrite(write-var, c@Var(chan-name), e)
    -> VarDeclaration([], data-type, Decl(Identifier(write-var)), None())
    where
      <not(?Var(_))> e // temp not necessary if it's just a var
      ; CSPChan(data-type@Type(_, data-type')) := <get-type> c
      ; <not(generate-csp-numeric-out-fn-name)> data-type'

  // chan write int types
  generate02:
    CSPChanWrite(_, c@Var(chan-name), expr)
    -> Call(Var(Identifier(fn-name)), [Var(chan-name), expr])
    where
      CSPChan(data-type@Type(_, data-type')) := <get-type> c
      ; fn-name := <generate-csp-numeric-out-fn-name> data-type'

  // chan write when using a direct variable expression
  generate02:
    CSPChanWrite(_, c@Var(chan-name), expr@Var(_))
    -> Call(Var(Identifier("CSP_chanOutCopy")), [Var(chan-name), Address(expr), Sizeof(data-type)])
    where
      CSPChan(data-type@Type(_, data-type')) := <get-type> c

  // other types, using a complexer expression
  generate02:
    CSPChanWrite(temp-var, c@Var(chan-name), expr)
    -> Paren(
      Comma(
        Assign(
          Var(Identifier(temp-var)),
          Assign(),
          expr),
        [],
        Call(
          Var(Identifier("CSP_chanOutCopy")),
          [
            Var(chan-name),
            Address(Var(Identifier(temp-var))),
            Sizeof(data-type)
          ])))
    where
      CSPChan(data-type@Type(_, data-type')) := <get-type> c
      ; fn-name := <not(generate-csp-numeric-out-fn-name)> data-type'

  // chan read
  generate02:
    CSPChanRead(c@Var(chan-name), Var(dest-name))
    -> Call(
      Var(Identifier("CSP_chanInCopy")),
      [Var(chan-name), Address(Var(dest-name)), Sizeof(data-type)])
    where
      CSPChan(data-type) := <get-type> c

  // run parallel processes
  generate02:
    CSPPar(processes) -> CompoundStatement(<flatten-list> [proc-inits,
      ExpressionStatement(Some(
        Call(
          Var(Identifier("ProcPar")),
          <conc> (
            proc-adresses,
            [Null()]
          )
        )
      ))
    ])
    where
      proc-inits := <map(generate-create-init-process)> processes
      ; proc-adresses := <map(\
          CSPInvokeProcess(Identifier(name), _)
          -> Address(Var(Identifier(<conc-strings> (name, "_proc"))))
        \)> processes

  generate-create-init-process:
    CSPInvokeProcess(proc-id@Identifier(name), args)
    -> [
      VarDeclaration(
        [],
        Type([], TypedefName(Identifier("Process"))),
        Decl(Identifier(proc-name)),
        None()
      ),
      VarDeclaration(
        [],
        Type([], TypedefName(Identifier(proc-name-args-type))),
        Decl(Identifier(proc-name-args)),
        None()
      ),
      arg-assignments,
      ExpressionStatement(Some(
        Assign(
          Field(Var(Identifier(proc-name)), Identifier("args")),
          Assign(),
          Address(Var(Identifier(proc-name-args)))
        )
      )),
      ExpressionStatement(Some(
        Call(
          Var(Identifier("ProcInit")),
          [
            Address(Var(Identifier(proc-name))),
            Var(Identifier(name)),
            Null(),
            Integer("0"),
            Integer("0")
          ]
        )
      ))
    ]
    where
      proc-name := <conc-strings> (name, "_proc")
      ; proc-name-args-type := <conc-strings> (name, "_ProcessArgs")
      ; proc-name-args := <conc-strings> (proc-name, "_args")
      ; CSPProcessParameterList(proc-params) := <get-process-params> name
      ; arg-assignments := <zip ; map(generate-create-init-process-assign-arg(|proc-name-args))> (proc-params, args)

  generate-create-init-process-assign-arg(|var-name):
    (FunDefinitionParameter(_, Decl(name)), arg)
    -> ExpressionStatement(Some(
      Assign(Field(Var(Identifier(var-name)), name), Assign(), arg)
    ))
