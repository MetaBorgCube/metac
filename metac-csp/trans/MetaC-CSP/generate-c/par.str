module MetaC-CSP/generate-c/par

imports

  signatures/BaseC-sig
  signatures/MetaC-CSP-sig
  BaseC/desugar/constructors
  names/MetaC-CSP/names
  names/BaseC/names/variables

rules

  // run parallel processes
  generate02:
    CSPPar(processes) -> CompoundStatement(<flatten-list> [
      chan-inits,
      proc-inits,
      ExpressionStatement(Some(
        Call(
          Var(Identifier("ProcPar")),
          <conc> (
            proc-adresses,
            [Null()]
          )
        )
      )),
      destroys
    ])
    where
      chan-inits := <generate-create-chan-inits> processes
      ; proc-inits := <map-with-index(generate-create-init-process)> processes
      ; proc-adresses := <map-with-index(\
          (i, CSPInvokeProcess(Identifier(name), _, state))
          -> Address(Var(Identifier(<concat-strings> [name, "_proc_", <int-to-string> i])))
        \)> processes
      ; destroys := <map-with-index(generate-destroy-process)> processes

  generate-create-chan-inits =
    collect-all(?Var(_))
    ; map(generate-create-chan-init <+ ![])
    ; flatten-list

  generate-create-chan-init:
    v@Var(Identifier(name))
    -> If(
      Equal(v, Null()),
      CompoundStatement([
        VarDeclaration(
          [],
          Type([], TypedefName(Identifier("Channel"))),
          Decl(Identifier(temp-var-name)),
          None()
        ),
        ExpressionStatement(Some(
          Assign(
            Var(Identifier(name)),
            Assign(),
            Address(Var(Identifier(temp-var-name)))
          )
        )),
        ExpressionStatement(Some(
          Call(
            Var(Identifier("CSP_chanInit")),
            [
              Var(Identifier(name)),
              Var(Identifier("CSP_ONE2ONE_CHANNEL")),
              Integer("0")
            ]
          )
        ))
      ])
    )
    where
      <get-type ; ?CSPChan(_)> v
      ; <get-storage ; debug> v
      ; temp-var-name := $[__[name]_csp_channel]

  generate-create-init-process:
    (i, CSPInvokeProcess(proc-id@Identifier(name), args, states'))
    -> [
      VarDeclaration(
        [],
        Type([], TypedefName(Identifier("Process"))),
        Decl(Identifier(proc-name)),
        None()
      ),
      VarDeclaration(
        [],
        Type([], TypedefName(Identifier(proc-name-args-type))),
        Decl(Identifier(proc-name-args)),
        None()
      ),
      arg-assignments,
      ExpressionStatement(Some(
        Assign(
          Field(Var(Identifier(proc-name)), Identifier("args")),
          Assign(),
          Address(Var(Identifier(proc-name-args)))
        )
      )),
      ExpressionStatement(Some(
        Call(
          Var(Identifier("ProcInit")),
          [
            Address(Var(Identifier(proc-name))),
            Var(Identifier(name)),
            Null(),
            Integer("0"),
            Integer("0")
          ]
        )
      ))
    ]
    where
      proc-name := <concat-strings> [name, "_proc_", <int-to-string> i]
      ; proc-name-args-type := <conc-strings> (name, "_ProcessArgs")
      ; proc-name-args := <conc-strings> (proc-name, "_args")
      ; CSPProcessParameterList(proc-params) := <get-process-params> name
      ; proc-states := <get-process-state ; ?CSPStateParameterList(<id>) <+ ![]> name
      ; states := <?Some(CSPInvokeState(<id>)) <+ ![]> states'
      ; arg-assignments := <zip ; map(generate-create-init-process-assign-arg(|proc-name-args))> (
          <conc> (proc-params, proc-states),
          <conc> (args, states)
        )

  generate-create-init-process-assign-arg(|var-name):
    (FunDefinitionParameter(_, Decl(name)), arg)
    -> ExpressionStatement(Some(
      Assign(Field(Var(Identifier(var-name)), name), Assign(), arg)
    ))

  generate-destroy-process:
    (i, CSPInvokeProcess(Identifier(name), _, state))
    -> ExpressionStatement(Some(Call(
      Var(Identifier("ProcInitClean")),
      [Address(Var(Identifier(proc-name)))]
    )))
    where
      proc-name := <concat-strings> [name, "_proc_", <int-to-string> i]
