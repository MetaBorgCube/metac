module expressions

language Metac

test comma expression type [[
  float a() { return [[1, 2, 3.0]]; }
]] run get-type to Float32()

test assign expression [[
  void a(float b) { [[b = 2.3]]; }
]] run get-type to Float32()

test assign expression, assigning wrong type [[
  void a(float b) { b = a; }
]] 1 error

test conditional [[
  float a() { return [[1 ? 2 : 3]]; }
]] run get-type to UInt8()

test conditional, widens lhs [[
  float a() { return [[1 ? 1 : 2.1]]; }
]] run get-type to Float32()

test conditional, widens rhs [[
  float a() { return [[1 ? 1.1 : 2]]; }
]] run get-type to Float32()

test get type of add expr [[
  int32 f() { return [[2 + 2]]; }
]] run get-type to UInt8()

test non numeric error [[
  int32 f() { return 1 + f; }
]] /Numeric/

test add float and uint8 [[
  float f() { return [[2 + 2.0]]; }
]] run get-type to Float32()

test get type of mult expr [[
  int32 f() { return [[1 / '3']]; }
]] run get-type to UInt8()

test variable type [[
  const int32 a;
  int32 b = [[a]];
]] run get-type to Int32()

test variable type from higher scope [[
  int32 a = 1;
  int32 b = 2;
  int32 f() { return [[a]]; }
]] run get-type to Int32()

test using variables in expressions [[
  int32 a = 1;
  int32 b = 2;
  int32 c = [[a + b]];
]] run get-type to Int32()

test struct field type [[
  struct X {unsigned short x;};
  struct X a;
  uint32 b = [[a.x]];
]] run get-type to UInt16()

test union pointer field type [[
  struct X {unsigned short x;};
  struct X *a;
  uint32 b = [[a->x]];
]] run get-type to UInt16()

test deref [[
  void f(int8 *a) {
    [[*a]];
  }
]] run get-type to Int8

test address [[
  void f(int8 a) {
    [[&a]];
  }
]] run get-type to Pointer(Int8())

test parens [[
  int8 a;
  void f() { [[(a)]]; }
]] run get-type to Int8()

test paren/address/debug [[
  void f(int8 a) {
    [[*(&(a))]];
  }
]] run get-type to Int8()

test function call [[
  int8 f(){}
  void g() {
    [[f()]];
  }
]] run get-type to Int8()
