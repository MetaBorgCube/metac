module BaseC-disamb

imports

  libstratego-lib
  libstratego-aterm
  libstratego-sglr

  include/Metac

strategies

  disamb: (ast, _, _) -> <disamb> ast

  disamb =
    rules(td-names := [])
    ; traverse(try(disamb-typedef))

  traverse(s) =
    s ; all(enter-scope(s) <+ traverse(s))

  disamb-typedef =
    resolve-amb ; try(collect-name)
    <+ collect-name

  resolve-amb =
    try(disamb-comma)
    ; try(disamb-parameters(|<td-names>))
    ; try(disamb-parens-decl-or-func-decl(|<td-names>))
    ; try(disamb-func-decl-or-func-decl-ids(|<td-names>))
    ; try(disamb-expr-or-decl(|<td-names>))
    ; try(disamb-cast(|<td-names>))

  enter-scope(s) =
    (?CompoundStatement(_))
    ; {| td-names : traverse(s) |}

  collect-name =
    ?x ; collect-td-name ; !x

  collect-td-name =
    get-typedef-declaration-name
    ; ?name
    ; update-td-names(union | [name])

  update-td-names(s | ids) =
    rules(td-names := <s> (<td-names>, ids))

  test-collect-td-name =
    rules(td-names := [])
    ; collect-td-name
    ; td-names

rules

  get-typedef-declaration-name: Declaration(
      [Typedef() | _],
      [Declarator(_, Identifier(name))]
    ) -> name

rules

  is-valid-type(|names) =
    if (
      Type(TypedefName(Identifier(?name)))
      <+ TypedefName(Identifier(?name))
    ) then
      <elem> (name, names)
    else
      id
    end

rules

  is-valid-parameter(|names):
    p@Parameter(specifiers, _) -> p
    where
      <all(is-valid-type(|names))> specifiers

  is-valid-parameter(|names):
    p@AbstractParameter(specifiers, _) -> p
    where
      <all(is-valid-type(|names))> specifiers

rules

  // In some cases this thing shows up, where the Comma constructor has some
  // amb, with just one element in some form. If that's the case, use the other
  // non-comma constructor variant
  disamb-comma:
    amb([x@amb([_, _]), Some(Comma(amb([[_], [_]])))]) -> x

  disamb-comma:
    amb([x@Some(amb([_, _])), Some(Comma([amb([_, _])]))]) -> x

  disamb-comma:
    amb([x@amb([_, _]), Comma([amb([_, _])])]) -> x

  disamb-comma:
    amb([x@amb([_, _]), Comma(amb([[_], [_]]))]) -> x

rules

  disamb-parameter-sort:
    x@(AbstractParameter(_, _), Parameter(_, _)) -> x

  disamb-parameter(|names):
    amb(ambs) -> p
    where
      ps := <sort-list(LSort(disamb-parameter-sort)) ; reverse> ambs
      ; p := <fetch-elem(is-valid-parameter(|names))>

  disamb-parameters(|names):
    ParameterList(ps) -> ParameterList(params)
    where
      params := <map(try(disamb-parameter(|names)))> ps

rules

  // empty parameters parses to fun decl
  disamb-func-decl-or-func-decl-ids(|names):
    amb([
      FuncDeclIDs(_, []),
      func@FuncDecl(_, ParameterList([]))]
    ) -> func

  disamb-func-decl-or-func-decl-ids(|names):
    amb([
      ids@FuncDeclIDs(_, _),
      func@FuncDecl(_, ParameterList(parameterList))]
    ) -> x
    where
      x := <bottomup(is-valid-type(|names)) < !func + !ids> parameterList

rules

  internal-disamb-parens-decl-or-func-decl(|names):
    (specifiers, f, p) -> x
    where
      if <all(is-valid-type(|names))> specifiers then
        x := p
      else
        x:= f
      end

  disamb-parens-decl-or-func-decl(|names):
    amb([
      f@Declaration(_, _),
      p@Declaration(specifiers, [Declarator(_, ParensDecl(_)) | _])
    ]) -> <internal-disamb-parens-decl-or-func-decl(|names)> (specifiers, f, p)


  disamb-parens-decl-or-func-decl(|names):
    amb([
      p@Declaration(specifiers, [Declarator(_, ParensDecl(_)) | _]),
      f@Declaration(_, _)
    ]) -> <internal-disamb-parens-decl-or-func-decl(|names)> (specifiers, f, p)

rules

  disamb-expr-or-decl(|names):
    amb([expr@ExpressionStatement(_), decl@Declaration(specifiers, _)])
    -> <disamb-intern-expr-or-decl(|names)> (expr, decl, specifiers)

  disamb-expr-or-decl(|names):
    amb([decl@Declaration(specifiers, _), expr@ExpressionStatement(_)])
    -> <disamb-intern-expr-or-decl(|names)> (expr, decl, specifiers)

  disamb-intern-expr-or-decl(|names): (expr, decl, specifiers) -> x
    where
      if <all(is-valid-type(|names))> specifiers then
        x := decl
      else
        x := expr
      end

rules

  disamb-cast(|names):
    amb([a, b]) -> x
    where
      x := <disamb-intern-cast(|names)> (a, b)
      <+ x := <disamb-intern-cast(|names)> (b, a)

  disamb-intern-cast(|names): (a, b) -> x
  where
    <oncetd(?Cast(_, _) ; ?cast)> a
    ; Cast(TypeName(types, _), _) := cast
    ; if <all(is-valid-type(|names))> types then
        x := a
      else
        x := b
      end
