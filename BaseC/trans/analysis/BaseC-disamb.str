module BaseC-disamb

imports

  libstratego-lib
  libstratego-aterm
  libstratego-sglr

  include/Metac

strategies

  disamb: (ast, _, _) -> <disamb> ast

  disamb =
    rules(td-names := [])
    ; traverse(try(disamb-typedef))

  traverse(s) =
    s ; all(enter-scope(s) <+ traverse(s))

  disamb-typedef =
    resolve-amb ; try(collect-name)
    <+ collect-name

  resolve-amb =
    try(disamb-parameters(|<td-names>))
    ; try(disamb-parens-decl-or-func-decl(|<td-names>))
    ; try(disamb-func-decl-or-func-decl-ids(|<td-names>))

  enter-scope(s) =
    (?FunDef(_, _, _, _))
    ; {| td-names : traverse(s) |}

  collect-name =
    ?x ; collect-td-name ; !x

  collect-td-name =
    get-typedef-declaration-name
    ; ?name
    ; update-td-names(union | [name])

  update-td-names(s | ids) =
    rules(td-names := <s> (<td-names>, ids))

  test-collect-td-name =
    rules(td-names := [])
    ; collect-td-name
    ; td-names

rules

  get-typedef-declaration-name: Declaration(
      [Typedef() | _],
      [Declarator(_, Identifier(name))]
    ) -> name

  get-specifiers-type:
    specifiers -> type
    where
      type' := <fetch-elem(?Type(_))> specifiers
    ; Type(type) := type'

  get-parameter-type:
    Parameter(specifiers, _) -> <get-specifiers-type> specifiers

  get-parameter-type:
    AbstractParameter(specifiers, _) -> <get-specifiers-type> specifiers

  parameter-if-is-type(|names):
    p -> x
    where
      t := <get-parameter-type> p
    ; if ?Identifier(name) then
        <elem> (name, names) ; x := p
      else
        x := p
      end

rules

/*

ParameterList([
  amb([
    Parameter([Type(Int32)],Declarator(None,Identifier("c"))),
    AbstractParameter([Type(Int32),Type(Identifier("c"))],None)
  ])
])

[
  AbstractParameter([Type(Identifier("b"))],None),
  amb([
    Parameter([Const],Declarator(None,Identifier("B"))),
    AbstractParameter([Const,Type(Identifier("B"))],None)
  ]),
  AbstractParameter([Type(Identifier("B"))],None)])))
]
*/

  is-valid-type(|names):
    Type(Identifier(name)) -> <elem> (name, names)

  is-valid-type(|names) =
    not(?Type(_))

  is-valid-parameter(|names):
    p@Parameter(specifiers, _) -> p
    where
      all(is-valid-type(|names))

  is-valid-parameter(|names):
    p@AbstractParameter(specifiers, _) -> p
    where
      all(is-valid-type(|names))

  disamb-parameter(|names):
    amb(ambs) -> <fetch-elem(is-valid-parameter(|names))> ambs

  disamb-parameters(|names):
    ParameterList(ps) -> ParameterList(params)
    where
      params := <map(disamb-parameter(|names) <+ id)> ps

rules

  // empty parameters parses to fun decl
  disamb-func-decl-or-func-decl-ids(|names):
    amb([
      FuncDeclIDs(_, []),
      func@FuncDecl(_, ParameterList([]))]
    ) -> func

  disamb-func-decl-or-func-decl-ids(|names):
    amb([
      ids@FuncDeclIDs(_, _),
      func@FuncDecl(_, ParameterList(parameterList))]
    ) -> x
    where
      if <bottomup(is-valid-type(|names))> parameterList then
        x := func
      else
        x := ids
      end

rules

  disamb-parens-decl-or-func-decl(|names):
    amb([
      p@Declaration(specifiers, [Declarator(_, ParensDecl(_))]),
      f@Declaration(_, _)
    ]) -> x
    where
      if <all(is-valid-type(|names))> specifiers then
        x := p
      else
        x:= f
      end

